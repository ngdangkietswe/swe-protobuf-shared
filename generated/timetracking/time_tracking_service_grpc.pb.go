// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             (unknown)
// source: timetracking/time_tracking_service.proto

package timetracking

import (
	context "context"
	common "github.com/ngdangkietswe/swe-protobuf-shared/generated/common"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	TimeTrackingService_CheckIn_FullMethodName             = "/timetracking.TimeTrackingService/CheckIn"
	TimeTrackingService_CheckOut_FullMethodName            = "/timetracking.TimeTrackingService/CheckOut"
	TimeTrackingService_GetTimeTracking_FullMethodName     = "/timetracking.TimeTrackingService/GetTimeTracking"
	TimeTrackingService_GetListTimeTracking_FullMethodName = "/timetracking.TimeTrackingService/GetListTimeTracking"
	TimeTrackingService_Overtime_FullMethodName            = "/timetracking.TimeTrackingService/Overtime"
	TimeTrackingService_ApproveOvertime_FullMethodName     = "/timetracking.TimeTrackingService/ApproveOvertime"
)

// TimeTrackingServiceClient is the client API for TimeTrackingService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type TimeTrackingServiceClient interface {
	CheckIn(ctx context.Context, in *CheckInReq, opts ...grpc.CallOption) (*CheckInOutResp, error)
	CheckOut(ctx context.Context, in *CheckOutReq, opts ...grpc.CallOption) (*CheckInOutResp, error)
	GetTimeTracking(ctx context.Context, in *GetTimeTrackingReq, opts ...grpc.CallOption) (*GetTimeTrackingResp, error)
	GetListTimeTracking(ctx context.Context, in *GetListTimeTrackingReq, opts ...grpc.CallOption) (*GetListTimeTrackingResp, error)
	Overtime(ctx context.Context, in *OverTimeReq, opts ...grpc.CallOption) (*common.UpsertResp, error)
	ApproveOvertime(ctx context.Context, in *ApproveOvertimeReq, opts ...grpc.CallOption) (*common.EmptyResp, error)
}

type timeTrackingServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewTimeTrackingServiceClient(cc grpc.ClientConnInterface) TimeTrackingServiceClient {
	return &timeTrackingServiceClient{cc}
}

func (c *timeTrackingServiceClient) CheckIn(ctx context.Context, in *CheckInReq, opts ...grpc.CallOption) (*CheckInOutResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CheckInOutResp)
	err := c.cc.Invoke(ctx, TimeTrackingService_CheckIn_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *timeTrackingServiceClient) CheckOut(ctx context.Context, in *CheckOutReq, opts ...grpc.CallOption) (*CheckInOutResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CheckInOutResp)
	err := c.cc.Invoke(ctx, TimeTrackingService_CheckOut_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *timeTrackingServiceClient) GetTimeTracking(ctx context.Context, in *GetTimeTrackingReq, opts ...grpc.CallOption) (*GetTimeTrackingResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetTimeTrackingResp)
	err := c.cc.Invoke(ctx, TimeTrackingService_GetTimeTracking_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *timeTrackingServiceClient) GetListTimeTracking(ctx context.Context, in *GetListTimeTrackingReq, opts ...grpc.CallOption) (*GetListTimeTrackingResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetListTimeTrackingResp)
	err := c.cc.Invoke(ctx, TimeTrackingService_GetListTimeTracking_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *timeTrackingServiceClient) Overtime(ctx context.Context, in *OverTimeReq, opts ...grpc.CallOption) (*common.UpsertResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(common.UpsertResp)
	err := c.cc.Invoke(ctx, TimeTrackingService_Overtime_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *timeTrackingServiceClient) ApproveOvertime(ctx context.Context, in *ApproveOvertimeReq, opts ...grpc.CallOption) (*common.EmptyResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(common.EmptyResp)
	err := c.cc.Invoke(ctx, TimeTrackingService_ApproveOvertime_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// TimeTrackingServiceServer is the server API for TimeTrackingService service.
// All implementations must embed UnimplementedTimeTrackingServiceServer
// for forward compatibility.
type TimeTrackingServiceServer interface {
	CheckIn(context.Context, *CheckInReq) (*CheckInOutResp, error)
	CheckOut(context.Context, *CheckOutReq) (*CheckInOutResp, error)
	GetTimeTracking(context.Context, *GetTimeTrackingReq) (*GetTimeTrackingResp, error)
	GetListTimeTracking(context.Context, *GetListTimeTrackingReq) (*GetListTimeTrackingResp, error)
	Overtime(context.Context, *OverTimeReq) (*common.UpsertResp, error)
	ApproveOvertime(context.Context, *ApproveOvertimeReq) (*common.EmptyResp, error)
	mustEmbedUnimplementedTimeTrackingServiceServer()
}

// UnimplementedTimeTrackingServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedTimeTrackingServiceServer struct{}

func (UnimplementedTimeTrackingServiceServer) CheckIn(context.Context, *CheckInReq) (*CheckInOutResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CheckIn not implemented")
}
func (UnimplementedTimeTrackingServiceServer) CheckOut(context.Context, *CheckOutReq) (*CheckInOutResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CheckOut not implemented")
}
func (UnimplementedTimeTrackingServiceServer) GetTimeTracking(context.Context, *GetTimeTrackingReq) (*GetTimeTrackingResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTimeTracking not implemented")
}
func (UnimplementedTimeTrackingServiceServer) GetListTimeTracking(context.Context, *GetListTimeTrackingReq) (*GetListTimeTrackingResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetListTimeTracking not implemented")
}
func (UnimplementedTimeTrackingServiceServer) Overtime(context.Context, *OverTimeReq) (*common.UpsertResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Overtime not implemented")
}
func (UnimplementedTimeTrackingServiceServer) ApproveOvertime(context.Context, *ApproveOvertimeReq) (*common.EmptyResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ApproveOvertime not implemented")
}
func (UnimplementedTimeTrackingServiceServer) mustEmbedUnimplementedTimeTrackingServiceServer() {}
func (UnimplementedTimeTrackingServiceServer) testEmbeddedByValue()                             {}

// UnsafeTimeTrackingServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to TimeTrackingServiceServer will
// result in compilation errors.
type UnsafeTimeTrackingServiceServer interface {
	mustEmbedUnimplementedTimeTrackingServiceServer()
}

func RegisterTimeTrackingServiceServer(s grpc.ServiceRegistrar, srv TimeTrackingServiceServer) {
	// If the following call pancis, it indicates UnimplementedTimeTrackingServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&TimeTrackingService_ServiceDesc, srv)
}

func _TimeTrackingService_CheckIn_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CheckInReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TimeTrackingServiceServer).CheckIn(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TimeTrackingService_CheckIn_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TimeTrackingServiceServer).CheckIn(ctx, req.(*CheckInReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _TimeTrackingService_CheckOut_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CheckOutReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TimeTrackingServiceServer).CheckOut(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TimeTrackingService_CheckOut_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TimeTrackingServiceServer).CheckOut(ctx, req.(*CheckOutReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _TimeTrackingService_GetTimeTracking_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTimeTrackingReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TimeTrackingServiceServer).GetTimeTracking(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TimeTrackingService_GetTimeTracking_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TimeTrackingServiceServer).GetTimeTracking(ctx, req.(*GetTimeTrackingReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _TimeTrackingService_GetListTimeTracking_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetListTimeTrackingReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TimeTrackingServiceServer).GetListTimeTracking(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TimeTrackingService_GetListTimeTracking_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TimeTrackingServiceServer).GetListTimeTracking(ctx, req.(*GetListTimeTrackingReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _TimeTrackingService_Overtime_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OverTimeReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TimeTrackingServiceServer).Overtime(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TimeTrackingService_Overtime_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TimeTrackingServiceServer).Overtime(ctx, req.(*OverTimeReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _TimeTrackingService_ApproveOvertime_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ApproveOvertimeReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TimeTrackingServiceServer).ApproveOvertime(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TimeTrackingService_ApproveOvertime_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TimeTrackingServiceServer).ApproveOvertime(ctx, req.(*ApproveOvertimeReq))
	}
	return interceptor(ctx, in, info, handler)
}

// TimeTrackingService_ServiceDesc is the grpc.ServiceDesc for TimeTrackingService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var TimeTrackingService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "timetracking.TimeTrackingService",
	HandlerType: (*TimeTrackingServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CheckIn",
			Handler:    _TimeTrackingService_CheckIn_Handler,
		},
		{
			MethodName: "CheckOut",
			Handler:    _TimeTrackingService_CheckOut_Handler,
		},
		{
			MethodName: "GetTimeTracking",
			Handler:    _TimeTrackingService_GetTimeTracking_Handler,
		},
		{
			MethodName: "GetListTimeTracking",
			Handler:    _TimeTrackingService_GetListTimeTracking_Handler,
		},
		{
			MethodName: "Overtime",
			Handler:    _TimeTrackingService_Overtime_Handler,
		},
		{
			MethodName: "ApproveOvertime",
			Handler:    _TimeTrackingService_ApproveOvertime_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "timetracking/time_tracking_service.proto",
}
